性能优化
-

MySQL性能优化主要在下面几个方面

- 建表优化
- 查询优化
- 使用索引
- 分区
- 分表
- 分库

## 建表优化

1. NULL

存在NULL额外占用空间且难以优化，建议字段声明`NOT NULL`，使用`""`或者`0`代替NULL

2. 数字类型

根据取值范围、应用场景选择合适的数字类型，非负数使用`UNSIGNED`

3. 枚举类型 

使用数字类型代替枚举类型

4. 日期类型

尽量使用TIMESTAMP而非DATETIME

5. 字段数量

单表20字段以内

6. IP

使用非负整数存储IP。IP（如：127.0.0.1）是由4个8位二进制数字组成，连接在一起是32位二进制数字，可以转换为十进制数字

MySQL提供INET_ATON和INET_NTOA函数，将IP字符串和十进制数字之间转换

## 查询优化

1. SELECT

查询具体的列代替SELECT *

2. WHERE

避免对字段进行NULL判断，会放弃索引

避免LIKE '%xxx'式查询，会放弃索引

3. LIMIT

使用LIMIT对查询结果的记录进行限定，例如：根据手机号查询用户，使用LIMIT 1限制，避免查询到结果后进行没必要的全表扫描











### 使用[索引](index.md)

1. GROUP BY、ORDER BY、ON条件中出现的列
2. WHERE中<，<=，=，>，>=，BETWEEN，IN，以及LIKE 字符串+通配符（%）出现的列

### 分析SQL

EXPLAIN命令

## 使用索引

1. 枚举类型自带索引

2. 重复值较多的列，如：性别，不使用索引，增加系统维护时间、消耗了空间、不能显著提高查询速度







4. 字符类型只做[前缀索引](https://www.cnblogs.com/studyzy/p/4310653.html)，不做主键

5. 不使用外键

6. 尽量不适用UNIQUE

7. 多列索引，顺序与查询条件一致，同时删除相关单列索引

## 合适的数据类型

1. 使用可存下数据最小的数据类型。优先级 ：整型 > date、time > char、varchar > blob
2. 使用简单的数据类型。如 ：int存储时间，bigint存储ip
3. 使用合理的字段长度。enum、char 优先于 varchar

5. 避免使用text，若必须使用，尽量分表

## SQL优化




3.使用连接（join）来代替子查询

4.拆分大的delete或insert语句

5.可通过开启慢查询日志来找出较慢的SQL

6.不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边

7.sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库

8.OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内

9.不用函数和触发器，在应用程序实现



11.少用JOIN

12.使用同类型进行比较，比如用'123'和'123'比，123和123比

13.尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描

14.对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5

15.列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大

## 引擎

目前广泛使用的是MyISAM和InnoDB两种引擎：

MyISAM

MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：

1.不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁

2.不支持事务

3.不支持外键

4.不支持崩溃后的安全恢复

5.在表有读取查询的同时，支持往表中插入新纪录

6.支持BLOB和TEXT的前500个字符索引，支持全文索引

7.支持延迟更新索引，极大提升写入性能

8.对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

InnoDB

InnoDB在MySQL 5.5后成为默认索引，它的特点是：

1.支持行锁，采用MVCC来支持高并发

2.支持事务

3.支持外键

4.支持崩溃后的安全恢复

5.不支持全文索引

总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表

MyISAM速度可能超快，占用存储空间也小，但是程序要求事务支持，故InnoDB是必须的，故该方案无法执行，放弃！

3.分区

MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码

对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引

用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，我测试，查询时不带分区条件的列，也会提高速度，故该措施值得一试。

分区的好处是：

1.可以让单表存储更多的数据

2.分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作

3.部分查询能够从查询条件确定只落在少数分区上，速度会很快

4.分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备

5.可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争

6.可以备份和恢复单个分区

分区的限制和缺点：

1.一个表最多只能有1024个分区

2.如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来

3.分区表无法使用外键约束

4.NULL值会使分区过滤无效

5.所有分区必须使用相同的存储引擎

分区的类型：

1.RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区

2.LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择

3.HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式

4.KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值

5.具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。

我首先根据月份把上网记录表RANGE分区了12份，查询效率提高6倍左右，效果不明显，故：换id为HASH分区，分了64个分区，查询速度提升显著。问题解决！

结果如下：PARTITION BY HASH (id)PARTITIONS 64

select count() from readroom_website; --11901336行记录

/ 受影响行数: 0 已找到记录: 1 警告: 0 持续时间 1 查询: 5.734 sec. /

select * from readroom_website where month(accesstime) =11 limit 10;

/ 受影响行数: 0 已找到记录: 10 警告: 0 持续时间 1 查询: 0.719 sec. */

4.分表

分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。

分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100

但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高！！！而且选择这个方案，都不如选择我提供的第二第三个方案的成本低！故不建议采用。

5.分库

把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失！不推荐使用。

方案二详细说明：升级数据库，换一个100%兼容mysql的数据库

mysql性能不行，那就换个。为保证源程序代码不修改，保证现有业务平稳迁移，故需要换一个100%兼容mysql的数据库。

开源选择

1.tiDB https://github.com/pingcap/tidb

2.Cubrid https://www.cubrid.org/

3.开源数据库会带来大量的运维成本且其工业品质和MySQL尚有差距，有很多坑要踩，如果你公司要求必须自建数据库，那么选择该类型产品。

云数据选择

1.阿里云POLARDB

2.https://www.aliyun.com/product/polardb?spm=a2c4g.11174283.cloudEssentials.47.7a984b5cS7h4wH

官方介绍语：POLARDB 是阿里云自研的下一代关系型分布式云原生数据库，100%兼容MySQL，存储容量最高可达 100T，性能最高提升至 MySQL 的 6 倍。POLARDB 既融合了商业数据库稳定、可靠、高性能的特征，又具有开源数据库简单、可扩展、持续迭代的优势，而成本只需商用数据库的 1/10。

我开通测试了一下，支持免费mysql的数据迁移，无操作成本，性能提升在10倍左右，价格跟rds相差不多，是个很好的备选解决方案！

1.阿里云OcenanBase

2.淘宝使用的，扛得住双十一，性能卓著，但是在公测中，我无法尝试，但值得期待

3.阿里云HybridDB for MySQL (原PetaData)

4.https://www.aliyun.com/product/petadata?spm=a2c4g.11174283.cloudEssentials.54.7a984b5cS7h4wH

官方介绍：云数据库HybridDB for MySQL （原名PetaData）是同时支持海量数据在线事务（OLTP）和在线分析（OLAP）的HTAP（Hybrid Transaction/Analytical Processing）关系型数据库。

我也测试了一下，是一个olap和oltp兼容的解决方案，但是价格太高，每小时高达10块钱，用来做存储太浪费了，适合存储和分析一起用的业务。

1.腾讯云DCDB

2.https://cloud.tencent.com/product/dcdb_for_tdsql

官方介绍：DCDB又名TDSQL，一种兼容MySQL协议和语法，支持自动水平拆分的高性能分布式数据库——即业务显示为完整的逻辑表，数据却均匀的拆分到多个分片中；每个分片默认采用主备架构，提供灾备、恢复、监控、不停机扩容等全套解决方案，适用于TB或PB级的海量数据场景。

腾讯的我不喜欢用，不多说。原因是出了问题找不到人，线上问题无法解决头疼！但是他价格便宜，适合超小公司，玩玩。

方案三详细说明：去掉mysql，换大数据引擎处理数据

数据量过亿了，没得选了，只能上大数据了。

开源解决方案

hadoop家族。hbase/hive怼上就是了。但是有很高的运维成本，一般公司是玩不起的，没十万投入是不会有很好的产出的！

云解决方案

这个就比较多了，也是一种未来趋势，大数据由专业的公司提供专业的服务，小公司或个人购买服务，大数据就像水/电等公共设施一样，存在于社会的方方面面。

国内做的最好的当属阿里云。

我选择了阿里云的MaxCompute配合DataWorks，使用超级舒服，按量付费，成本极低。

MaxCompute可以理解为开源的Hive，提供sql/mapreduce/ai算法/python脚本/shell脚本等方式操作数据，数据以表格的形式展现，以分布式方式存储，采用定时任务和批处理的方式处理数据。DataWorks提供了一种工作流的方式管理你的数据处理任务和调度监控。

当然你也可以选择阿里云hbase等其他产品，我这里主要是离线处理，故选择MaxCompute，基本都是图形界面操作，大概写了300行sql，费用不超过100块钱就解决了数据处理问题。