垃圾回收算法
-

垃圾回收相关算法，包含下面几类：

- 用于确定对象可回收
	- 引用计数法
	- 可达性算法（JVM使用）
- 用于回收对象
	- 标记-清除算法
	- 复制算法（常用于新生代）
	- 标记-整理算法（常用于老年代）
	- 分代收集算法

###### 引用计数法

对象添加引用计数器，每次引用+1，引用失效-1，计数器为0表示对象可回收

当对象循环引用，导致无法回收。例如：A和B互相引用

###### 可达性算法

将GC Roots作为启点，向下搜索引用链，若对象不与任何一个引用链相连，则表示可回收

常用来作为引用链的有以下几种：

- 虚拟机栈中引用的对象（本地变量表）
- 本地方法栈中引用的对象（JNI）
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象

###### 标记-清除算法

Mark-Sweep。分为两步：一、标记出所有需要回收的对象；二、统一回收

缺点：

1. 效率较低
2. 会产生空间碎片，导致大对象申请空间时，空间不足

###### 复制算法

Coping。将空间划分为大小相等的两块，每次只使用其中一块，当垃圾清理时，将存活的对象复制到另一块上

优点：解决了标记-清除算法的缺点

缺点：内存缩小为原来一半

HotSpot将新生代划分为Eden、S0、S1，默认比例8:1:1，每次只使用Eden和S0、S1中的一块区域，仅仅10%的内存未被使用

###### 标记-整理算法

Mark-Compact。类似Mark-Sweep，但是标记后，现将存活对象移动到一端，然后清理边界外空间

缺点：效率低

老年代对象存活率较高，若使用复制算法，不仅效率低，且浪费空间，一般使用该算法

###### 分代收集算法

将内存划分为几块，分别采用不同的收集算法。

新生代收集率高，采用复制算法，复制少量对象就可以完成回收

老年代收集率低，采用标记-清除/整理算法，回收掉不需要的对象