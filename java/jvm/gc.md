GC
-

### 基本原理

内存管理的实质就是对象的管理，包括对象的分配和释放。

GC在创建对象时，就开始监控对象的地址、大小及使用情况，通常采用有向图的方式记录和管理堆中的对象，确定哪些对象是可达的，回收不可达对象。

新生代GC（Young GC）一般叫做Minor GC，老年代GC叫做Major GC，整体GC叫做Full GC

### 增量式GC（Incremental GC）

GC在JVM中通常由一个或一组进程实现，也会占用堆空间，占用CPU。

GC运行时，应用停止。运行时间长，用户会感受到到停顿；运行时间短，则回收率低。设计时，需要在停顿时间和回收率之间权衡。

增量式GC通过一定的GC算法，通过一定的回收算法，把一个长时间的中断划分为多个小中断。性能不如普通GC，但减少最长停顿时间。

HotSpot JVM默认不启用增量式GC，通过-Xincgc参数启用。

HotSpot JVM增量式GC采用了Train GC算法。它的基本想法就是，将堆中的所有对象按照创建和使用情况进行分组（分层），将使用频繁高和具有相关性的
对象放在一队中，随着程序的运行，不断对组进行调整。当GC运行时，它总是先回收最老的（最近很少访问的）的对象，如果整组都为可回收对象，GC将整组
回收。这样，每次GC运行只回收一定比例的不可达对象，保证程序的顺畅运行。

### finalize函数

finalize函数最后一句是super.finalize()，保证先释放自己的资源再释放父类的资源。

JVM在对象不可达时调用finalize()，但不保证一定调用，最多调用一次。

避免使用finalize()释放资源，原因：

1. GC会对覆盖finalize()的对象做很多附加工作来支持该函数
2. 运行之后，对象可能由于其他原因变成可达，GC还会再次检查该对象是否可达，导致降低GC性能
3. 调用finalize()的时间不确定

可以将一些重要的资源释放写入，如：I/O、数据库连接，程序释放为主、finalize()为辅，双保险的释放。

```java
public class Foo {
    static Foo foo;
    protected void finalize(){
        // 通过该方法使对象变为可达
        foo = this;
    }
}
```

### 建议

根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。以下就是一些程序设计的几点建议。

1.最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null.这样可以加速GC的工作。

2.尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。

3.如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory.

4.注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。

5.当程序有一定的等待时间，程序员可以手动执行System.gc（），通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。

[Minor、Major、Full GC](http://www.importnew.com/15820.html)

